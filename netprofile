#!/bin/bash
#
# This is netprofile, an application which allows to use
# different sets of network profiles on same physical network connections.
#
# Copyright, (C) Mandriva, 2003-2009.
# Copyright, (C) Frederic Lepied, 2003-2005
# Copyright, (C) Eugeni Dodonov, 2009
#
# TODO: security concerns (profiles containing '/', ';' or '..')
# TODO: implement check command (to check for changes in profile)
# TODO: implement getopt support

NETPROFILE=/etc/netprofile
PROFILES=$NETPROFILE/profiles
MODULES=$NETPROFILE/modules
CURRENT=$NETPROFILE/current
VERBOSE=0
LOG=/var/log/netprofile.log
DATE=$(date)
LOG_TMP=$(mktemp)

function cleanup {
        rm -f $LOG_TMP
}
trap cleanup 0
# TODO: handle other signals gracefully

function restore_files {
        PROFILE=$1
        MODULE=$2
        FILES=$3
        # restoring old files
        SAVED_FILES="$PROFILES/$PROFILE/$MODULE"
        log " ** restoring files for $MODULE from $SAVED_FILES"
        rm -f $LOG_TMP
        (cd $SAVED_FILES && tar cpf - . 2>>$LOG_TMP) | (cd / && tar xpf - 2>>$LOG_TMP)
        catlog
}

function remove_files {
        PROFILE=$1
        MODULE=$2
        FILES=$3
        log " ** removing files to restore $MODULE from $PROFILE"
        rm -f $LOG_TMP
        rm -rf -- $(echo $FILES) 2>>$LOG_TMP
        catlog
}

function save_files {
        PROFILE=$1
        MODULE=$2
        FILES=$3
        # saving files
        SAVED_FILES="$PROFILES/$PROFILE/$MODULE"
        if [ ! -d "$SAVED_FILES" ]; then
                log "creating profile directory: $SAVED_FILES"
                mkdir -p $SAVED_FILES
        fi
        log " ** copying files for $MODULE into $SAVED_FILES"
        rm -f $LOG_TMP
        tar cpf - $(echo $FILES) 2>>$LOG_TMP | (cd $SAVED_FILES && tar xpf -) 2>>$LOG_TMP
        catlog
}

function restart_services {
        SERVICES=$1
        for service in $SERVICES; do
                log " ** restarting service $service"
                rm -f $LOG_TMP
                test -e /etc/init.d/$service && service $service restart 2>>$LOG_TMP
                catlog
        done
}

function print_debug {
        if [ "a$VERBOSE" = "a1" ]; then
                echo "$*"
        fi
}

function log {
        print_debug "$1"
        echo "$DATE: $1" >> $LOG
}

function catlog {
        while read line; do
                echo "$DATE: $line" >> $LOG
        done < $LOG_TMP
}

function restore_profile {
        # sets a network profile
        PROFILE=$1
        RESTART_SERVICES=${1:-0}
        # do we have a profile?
        if [ ! -d "$PROFILES/$PROFILE" ]; then
                log "Profile $PROFILE does not exists"
                return 1
        else
                log "Restoring profile $PROFILE from $PROFILES/$PROFILE"
        fi
        for module in $MODULES/*; do
                # if module is not executable, disable it
                test -x $module || continue
                . $module
                print_debug "Removing old files for $NAME"
                remove_files "$PROFILE" "$NAME" "$FILES"
                print_debug "Restoring files for $NAME"
                restore_files "$PROFILE" "$NAME" "$FILES"
                if [ ! "a$RESTART_SERVICES" = "a0" ]; then
                        print_debug "Restarting services for $NAME"
                        restart_services "$SERVICES"
                fi
                restore "$PROFILE"
        done
}

function update_current {
        PROFILE=$1
        echo "$PROFILE" > $CURRENT
}

function save_profile {
        # saves current system settings into a profile
        PROFILE=$1
        test -d "$PROFILES/$PROFILE" || mkdir -p "$PROFILES/$PROFILE"
        log "Saving files for $PROFILE"
        for module in $MODULES/*; do
                # if module is not executable, disable it
                test -x $module || continue
                . $module
                save_files "$PROFILE" "$NAME" "$FILES"
                # calling module-specific hook
                save "$PROFILE"
        done
}

function remove_profile {
        # removes a network profile
        PROFILE=$1
        # do we have a profile?
        if [ ! -d "$PROFILES/$PROFILE" ]; then
                log "Profile $PROFILE does not exists"
                return 1
        else
                log "Removing profile $PROFILE from $PROFILES/$PROFILE"
        fi
        # TODO: save backup
        rm -rf "$PROFILES/$PROFILE"
}

function check_root {
        # must be run as root
        if [ ! "a$UID" = "a0" ]; then
                echo "Error: $0 must be run as root!"
                exit 1
        fi
}

function check_current_profile {
        if [ -z "$NEW_PROFILE" ]; then
                echo "Error: no profile specified"
                exit 1
        fi

        if [ "a$NEW_PROFILE" = "a$CURPROFILE" ]; then
                echo "The $NEW_PROFILE is the current profile."
                exit 1
        fi
}

function get_boot_profile {
        if [ -z "$NEW_PROFILE" ]; then
                # get profile name from cmdline
                NEW_PROFILE=$(cat /proc/cmdline | tr ' ' '\n' | grep PROFILE | cut -f 2 -d =)
        fi
        # no profile passed on command line, show user a menu
        if [[ -z "$NEW_PROFILE" && -x /usr/bin/fbmenu && -d /etc/netprofile/profiles/ ]]; then
                nb_profiles=`ls /etc/netprofile/profiles | wc -l`;
                if [[ "$nb_profiles" == "1" ]]; then
                        NEW_PROFILE=`basename /etc/netprofile/profiles/*`
                else 
                        _procsplash="`cat /proc/splash 2>/dev/null`"
                        grep -q silent /proc/cmdline && grep -q silent /proc/splash && _silent="yes"
                        if [ -z "$_silent" -o ! -r /proc/splash -o -z "`echo $_procsplash|grep on`" ]; then
                                if [[ -x /usr/bin/fbgrab ]]; then
                                        rm -f /tmp/bootsplash.png
                                        /usr/bin/fbgrab /tmp/bootsplash.png
                                fi
                        else
                                if [[ -z $res ]]; then 
                                        res=`fbresolution`
                                fi
                                if [[ -f /etc/sysconfig/bootsplash ]]; then
                                        . /etc/sysconfig/bootsplash
                                        theme=$THEME
                                        if [[ -f /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg ]]; then
                                                function box() { true; }
                                                . /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg
                                        fi
                                fi
                                if [[ -f $silentjpeg ]]; then
                                        rm -f /tmp/bootsplash.png
                                        cp -f $silentjpeg /tmp/bootsplash.png
                                fi
                        fi

                        pushd  /etc/netprofile/profiles/
                        if [[ -n "$CURPROFILE" ]]; then 
                                eval `GTK2_RC_FILES=/etc/bootsplash/themes/current/config/gtkrc /usr/bin/fbmenu 10 "Choose a network profile" "$CURPROFILE" * | grep RESULT`
                        else
                                eval `GTK2_RC_FILES=/etc/bootsplash/themes/current/config/gtkrc /usr/bin/fbmenu 10 "Choose a network profile" * | grep RESULT`
                        fi
                        if [[ "$_silent" == "yes" ]]; then
                                if [[ -f /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg ]]; then
                                        /sbin/splash -s -u 0 /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg
                                fi
                        fi
                        NEW_PROFILE="$RESULT"
                        popd
                fi
        fi
}

function reload_netapplet {
        # make net_applet reload the configuration
        # (needs "current" file to be up to date)
        PID=`pidof -x net_applet`
        [[ -n "$PID" ]] && kill -HUP $PID
}

function usage {
        cat << EOF
Usage: $0 [-options] <boot|switch|current|list|delete> [profile]

The switch operation will save the system configuration into current profile,
and restore files belonging to the new profile.  If the new profile does not
exists, it will be created with base on current configuration.

The boot operation will attempt to determine the profile from the kernel
command line, or show user a menu to select the desired profile.

The current operation will print the currently used profile.

The list operation will list available profiles.

The delete operation will delete an existent profile.

Options:
  -v, --verbose                 show detailed information on profile actions
  -h, --help                    show this help message

EOF
exit 0
}

NO_RESTART_NETWORK=

if [ "a$1" = "a" ]; then
        usage
fi

args=`getopt -o v,h -l verbose,help -n "$0" -- "$@"`
eval set -- "$args"

while true; do
        case "$1" in
                -v|--verbose) VERBOSE=1;        shift 1;;
                -h|--help) usage;               shift 1;;
                --)                             shift ; break;;
                *) echo "Invalid argument: $1"; exit 1 ;;
        esac
done

ACTION="$1"
NEW_PROFILE="$2"
CURPROFILE=$(cat $CURRENT 2>/dev/null)

if [ "a$ACTION" = "aswitch" ]; then
        check_root
        check_current_profile
        if [ ! -n "$CURPROFILE" ]; then
                # no current profile
                log "Creating initial profile $NEW_PROFILE"
                save_profile "$NEW_PROFILE"
        else
                log "Switching from profile $CURPROFILE to profile $NEW_PROFILE"
                save_profile "$CURPROFILE"
                restore_profile "$NEW_PROFILE" 1 || (log "Creating new profile $NEW_PROFILE"; save_profile "$NEW_PROFILE")
                reload_netapplet
        fi
        update_current "$NEW_PROFILE"
elif [ "a$ACTION" = "aboot" ]; then
        check_root
        get_boot_profile
        check_current_profile
        log "Switching from profile $CURPROFILE to profile $NEW_PROFILE"
        save_profile "$CURPROFILE"
        restore_profile "$NEW_PROFILE"
        update_current "$NEW_PROFILE"
        reload_netapplet
elif [ "a$ACTION" = "adelete" ]; then
        check_root
        check_current_profile
        print_debug "Removing profile $NEW_PROFILE"
        remove_profile "$NEW_PROFILE"
elif [ "a$ACTION" = "acurrent" ]; then
        echo $CURPROFILE
        exit 0
elif [ "a$ACTION" = "alist" ]; then
        # shows available netprofiles
        AVAILABLE_PROFILES=""
        (
                cd $PROFILES
                for z in *; do
                        if [ "$z" = "$CURPROFILE" ]; then
                                AVAILABLE_PROFILES="$AVAILABLE_PROFILES [$z]"
                        else
                                AVAILABLE_PROFILES="$AVAILABLE_PROFILES $z"
                        fi
                done
                echo $AVAILABLE_PROFILES
        )
        exit 0
else
        echo "$0: unknown action $ACTION"
        exit 1
fi

exit 0

# set-netprofile ends here
