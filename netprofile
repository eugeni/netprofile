#!/bin/bash
#
# This is netprofile, an application which allows to use
# different sets of network profiles on same physical network connections.
#
# Copyright, (C) Mandriva, 2003-2009.
# Copyright, (C) Frederic Lepied, 2003-2005
# Copyright, (C) Eugeni Dodonov, 2009
#
# TODO: security concerns (profiles containing '/', ';' or '..')

NETPROFILE=/etc/netprofile
PROFILES=$NETPROFILE/profiles
MODULES=$NETPROFILE/modules
CURRENT=$NETPROFILE/current
VERBOSE=1
LOG=/var/log/netprofile.log
DATE=$(date)
LOG_TMP=$(mktemp)

function cleanup {
        rm -f $LOG_TMP
}
trap cleanup 0
# TODO: handle other signals gracefully

function restore_files {
        PROFILE=$1
        MODULE=$2
        FILES=$3
        # restoring old files
        SAVED_FILES="$PROFILES/$PROFILE/$MODULE.tar.gz"
        echo "(cd / && test -e $SAVED_FILES && tar xpzf $SAVED_FILES)"
}

function save_files {
        PROFILE=$1
        MODULE=$2
        FILES=$3
        # saving files
        SAVED_FILES="$PROFILES/$PROFILE/$MODULE"
        log "creating profile directory: $SAVED_FILES"
        test -d "$SAVED_FILES" || mkdir -p $SAVED_FILES
        log "copying files for $MODULE into $SAVED_FILES"
        rm -f $LOG_TMP
        tar cpf - $(echo $FILES) 2>>$LOG_TMP | (cd $SAVED_FILES && tar xpf -) 2>>$LOG_TMP
        catlog
}

function restart_services {
        SERVICES=$1
        for service in $SERVICES; do
                log "restarting service $service"
                rm -f $LOG_TMP
                test -e /etc/init.d/$service && echo service $service restart 2>>$LOG_TMP
                catlog
        done
}

function print_debug {
        if [ "a$VERBOSE" = "a1" ]; then
                echo "$*"
        fi
}

function log {
        print_debug "$1"
        echo "$DATE: $1" >> $LOG
}

function catlog {
        while read line; do
                echo "$DATE: $line" >> $LOG
        done < $LOG_TMP
}

function restore_profile {
        # sets a network profile
        PROFILE=$1
        for module in $MODULES/*; do
                # if module is not executable, disable it
                test -x $module || continue
                . $module
                print_debug "Restoring files for $NAME"
                restore_files "$PROFILE" "$NAME" "$FILES"
                print_debug "Restarting services for $NAME"
                restart_services "$SERVICES"
                restore "$PROFILE"
        done
        # mark current profile as restored
        echo "$PROFILE" > $CURRENT
}

function save_profile {
        # saves current system settings into a profile
        PROFILE=$1
        test -d "$PROFILE" || mkdir -p "$PROFILE"
        for module in $MODULES/*; do
                # if module is not executable, disable it
                test -x $module || continue
                . $module
                print_debug "Saving files for $NAME"
                save_files "$PROFILE" "$NAME" "$FILES"
                save "$PROFILE"
        done
}

NO_RESTART_NETWORK=

# {{{ boot selection
if [[ -z "$NEWPROFILE" ]]; then
    # Check the kernel command line, profile are selectable
    # right from the boot manager
    eval `cat /proc/cmdline | tr ' ' '\n' | grep PROFILE`
    NEWPROFILE="$PROFILE"
    if [[ -z "$NEWPROFILE" && -x /usr/bin/fbmenu && -d /etc/netprofile/profiles/ ]]; then
        nb_profiles=`ls /etc/netprofile/profiles | wc -l`;
        if [[ "$nb_profiles" == "1" ]]; then
            NEWPROFILE=`basename /etc/netprofile/profiles/*`
        else 
            _procsplash="`cat /proc/splash 2>/dev/null`"
            grep -q silent /proc/cmdline && grep -q silent /proc/splash && _silent="yes"
            if [ -z "$_silent" -o ! -r /proc/splash -o -z "`echo $_procsplash|grep on`" ]; then
                if [[ -x /usr/bin/fbgrab ]]; then
                    rm -f /tmp/bootsplash.png
                    /usr/bin/fbgrab /tmp/bootsplash.png
                fi
            else
                if [[ -z $res ]]; then 
                    res=`fbresolution`
                fi
                if [[ -f /etc/sysconfig/bootsplash ]]; then
                    . /etc/sysconfig/bootsplash
                    theme=$THEME
                    if [[ -f /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg ]]; then
                        function box() { true; }
                        . /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg
                    fi
                fi
                if [[ -f $silentjpeg ]]; then
                    rm -f /tmp/bootsplash.png
                    cp -f $silentjpeg /tmp/bootsplash.png
                fi
            fi

            if [[ -r $TOP/current ]]; then
                eval `cat $TOP/current`
            fi
            pushd  /etc/netprofile/profiles/
            if [[ -n "$PROFILE" ]]; then 
                eval `GTK2_RC_FILES=/etc/bootsplash/themes/current/config/gtkrc /usr/bin/fbmenu 10 "Choose a profile" "$PROFILE" * | grep RESULT`
            else 
                eval `GTK2_RC_FILES=/etc/bootsplash/themes/current/config/gtkrc /usr/bin/fbmenu 10 "Choose a profile" * | grep RESULT`
            fi
            if [[ "$_silent" == "yes" ]]; then
                if [[ -f /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg ]]; then
                    /sbin/splash -s -u 0 /etc/bootsplash/themes/$theme/config/bootsplash-$res.cfg
                fi
            fi
            NEWPROFILE="$RESULT"
            popd
        fi
    fi
fi
# }}}

# must be run as root
if [ ! "a$UID" = "a0" ]; then
        echo "Error: $0 must be run as root!"
        exit 1
fi

if [ "a$2" = "a" ]; then
        cat << EOF
Usage: $0 <switch|update|delete> <profile>

The switch operation will save the system configuration into current profile,
and restore files belonging to the new profile.  If the new profile does not
exists, it will be created with base on current configuration.

EOF
        exit 1
fi

ACTION="$1"
PROFILE="$2"

CURPROFILE=$(cat $CURRENT)
if [ "a$PROFILE" = "a$CURPROFILE" ]; then
        echo "The $PROFILE is the current profile."
        exit 1
fi

if [ "a$ACTION" = "aswitch" ]; then
        print_debug "Switching from profile $CURPROFILE to profile $PROFILE"
elif [ "a$ACTION" = "adelete" ]; then
        print_debug "Removing profile $PROFILE"
else
        echo "$0: unknown action $ACTION"
        exit 1
fi

exit 0

restore_profile default
save_profile default

exit 0

# make net_applet reload the configuration
# (needs "current" file to be up to date)
PID=`pidof -x net_applet`
[[ -n "$PID" ]] && kill -HUP $PID

# set-netprofile ends here
